package waffleoRai_extractMyu.mains;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import waffleoRai_Utils.FileBuffer;
import waffleoRai_extractMyu.LiteNode;
import waffleoRai_extractMyu.Main;
import waffleoRai_extractMyu.MyuArcCommon;
import waffleoRai_extractMyu.MyuPackagerLogger;
import waffleoRai_extractMyu.tables.SymbolInfo;
import waffleoRai_extractMyu.tables.SymbolList;
import waffleoRai_extractMyu.tables.StructDef;
import waffleoRai_myuctempl.AsmScanning;
import waffleoRai_myuctempl.AsmScanning.AsmLine;
import waffleoRai_myuctempl.MCTModule;
import waffleoRai_myuctempl.MCTSymbol;

public class Data2C {
	
	//Multi
	
	private String xmldir; //For relative paths
	private String xmlpath;
	private List<String> symListPaths;
	private Map<Long, SymbolInfo> symbolMapAddr;
	private Map<String, SymbolInfo> symbolMapName;
	private List<LiteNode> modInfoList;
	private Map<String, StructDef> structDefs;
	
	//Single
	
	private String inpath;
	private String outpath;
	private String headerName;
	
	private String modName;
	
	public boolean checkArgs(Map<String, String> argmap) {
		xmlpath = argmap.get("xml");
		inpath = argmap.get("input");
		outpath = argmap.get("output");
		headerName = argmap.get("hname");
		
		if((xmlpath == null) && (inpath == null)){
			MyuPackagerLogger.logMessage("Data2C.checkArgs", 
					"At least one input is required!");
			return false;
		}
		
		if(xmlpath != null) {
			if(!FileBuffer.fileExists(xmlpath)){
				MyuPackagerLogger.logMessage("Data2C.checkArgs", 
						"Input file \"" + xmlpath + "\" does not exist!");
				return false;
			}
		}
		else {
			if(!FileBuffer.fileExists(inpath)){
				MyuPackagerLogger.logMessage("Data2C.checkArgs", 
						"Input file \"" + inpath + "\" does not exist!");
				return false;
			}
			
			if(outpath == null){
				MyuPackagerLogger.logMessage("Data2C.checkArgs", 
						"Please specify a .c output file path!");
				return false;
			}
			
			String fn = inpath;
			if(fn.contains(File.separator)) {
				fn = fn.substring(fn.lastIndexOf(File.separator) + 1);
			}
			if(fn.contains(".")) {
				fn = fn.substring(0, fn.indexOf('.'));
			}
			modName = fn;
			
			if(headerName == null){
				headerName = modName + ".h";
				MyuPackagerLogger.logMessage("Data2C.checkArgs", 
						"Header include name not specified. Set to: " + headerName);
			}	
		}

		return true;
	}
	
	private static String[] getSymbolValues(MCTSymbol symbol) {
		//TODO
		return null;
	}
	
	private static void writeCFileHead(BufferedWriter writer, String headerName) throws IOException {
		writer.write("/*---------------------------------------\n");
		writer.write("* .c file template autogenerated by MyuPackager\n");
		writer.write("* ---------------------------------------*/\n\n");
		
		writer.write("#include \"" + headerName + "\"\n");
		
		writer.write("\n#ifdef __cplusplus\n");
		writer.write("extern \"C\" {\n");
		writer.write("#endif\n\n");
	}
	
	private static void writeCFileFoot(BufferedWriter writer) throws IOException {
		writer.write("\n#ifdef __cplusplus\n");
		writer.write("}\n");
		writer.write("#endif\n");
	}
	
	private static void printSymbolToCFile(MCTSymbol symbol, BufferedWriter writer) throws IOException {
		String rtype = symbol.guessReturnType();
		writer.write("//\t.data 0x" + String.format("%08x", symbol.address) + "\n");
		writer.write("\t" + rtype + " " + symbol.name + "[] = {");
		int perRow = 8;
		if(rtype.equals("uint8_t")) perRow = 16;
		
		int i = 0;
		for(String line : symbol.asmLines) {
			if(line.isEmpty()) continue;
			if(line.startsWith("dlabel")) continue;
			if(line.startsWith(".size")) break;
			
			//There are some issues with splat hallucinating symbols in _udat5_dat_800f0100. These need to be corrected...
			if((i++ % perRow) == 0) {
				writer.write("\n\t\t");
			}
			
			AsmLine aline = AsmScanning.parseLine(line);
			writer.write(aline.args.get(0));
			
			writer.write(", ");
		}
		writer.write("\n\t};\n\n");
	}
	
	private static void printSymbolToCFile(BufferedWriter writer, long addr, String symName, String symType, List<String> elements, int elementsPerLine) throws IOException {
		writer.write("//\t.data 0x" + String.format("%08x", addr) + "\n");
		writer.write("\t" + symType + " " + symName + "[] = {");
		int i = 0;
		for(String element : elements) {
			if((i++ % elementsPerLine) == 0) {
				writer.write("\n\t\t");
			}
			writer.write(element);
			writer.write(", ");
		}
		writer.write("\n\t};\n\n");
	}
	
	private FileBuffer asmLines2Bin(MCTSymbol symbol, int sizeBytes) {
		FileBuffer bin = new FileBuffer(sizeBytes, false);
		for(String asmline : symbol.asmLines) {
			if(asmline.isEmpty()) continue;
			AsmLine aline = AsmScanning.parseLine(asmline);
			if(aline == null) continue;
			if(aline.cmd.equals(".size")) break;
			if(aline.cmd.equals(".word")) {
				//Either 32-bit literal or symbol
				//Sometimes hallucinates symbols
				String arg0 = aline.args.get(0);
				if(arg0.startsWith("0x")) {
					int wval = Integer.parseUnsignedInt(arg0.substring(2), 16);
					bin.addToFile(wval);
				}
				else {
					String sname = null;
					int addend = 0;
					if(arg0.contains("+")) {
						String[] spl = arg0.split("+");
						sname = spl[0].trim();
						addend = Integer.parseUnsignedInt(spl[1].substring(2), 16);
					}
					else sname = arg0;
					
					SymbolInfo sinfo = symbolMapName.get(sname);
					if(sinfo != null) {
						long addr = sinfo.address + addend;
						bin.addToFile((int)addr);
					}
					else {
						MyuPackagerLogger.logMessage("Data2C.asmLines2Bin", 
								"WARNING: Symbol \"" + sname + "\" not recognized! Replacing with NULL pointer!");
						bin.addToFile(0);
					}
				}
			}
			else if(aline.cmd.equals(".byte")) {
				String arg0 = aline.args.get(0);
				if(arg0.startsWith("0x")) {
					int val = Integer.parseUnsignedInt(arg0.substring(2), 16);
					bin.addToFile((byte)val);
				}
				else {
					MyuPackagerLogger.logMessage("Data2C.asmLines2Bin", 
							"WARNING: Did not recognize \"" + arg0 + "\" as argument for .byte! Replacing with 0!");
					bin.addToFile((byte)0);
				}
			}
			else if(aline.cmd.equals(".asciz")) {
				String arg0 = aline.args.get(0);
				arg0 = arg0.replace("\"", "");
				bin.printASCIIToFile(arg0);
				bin.addToFile((byte)0);
			}
			else if(aline.cmd.equals(".short")) {
				String arg0 = aline.args.get(0);
				if(arg0.startsWith("0x")) {
					int val = Integer.parseUnsignedInt(arg0.substring(2), 16);
					bin.addToFile((short)val);
				}
				else {
					MyuPackagerLogger.logMessage("Data2C.asmLines2Bin", 
							"WARNING: Did not recognize \"" + arg0 + "\" as argument for .short! Replacing with 0!");
					bin.addToFile((byte)0);
				}
			}
			else if(aline.cmd.equals(".align")) {
				String arg0 = aline.args.get(0);
				int val = Integer.parseInt(arg0);
				while((bin.getFileSize() % val) != 0) {
					bin.addToFile((byte)0);
				}
			}
			else {
				/*MyuPackagerLogger.logMessage("Data2C.asmLines2Bin", 
						"ERROR: Asm command \"" + aline.cmd + "\" not recognized!");
				return null;*/
			}
		}
		
		return bin;
	}
	
	private void doModule(LiteNode mnode) throws IOException {
		String mname = mnode.attr.get("Name");
		
		MyuPackagerLogger.logMessage("Data2C.doModule", "Working on module: " + mname);
		MCTModule mod = new MCTModule();
		mod.modName = mname;
		
		String asmPath = mnode.attr.get("AsmFile");
		asmPath = MyuArcCommon.unixRelPath2Local(xmldir, asmPath);
		String cPath = mnode.attr.get("CFile");
		cPath = MyuArcCommon.unixRelPath2Local(xmldir, cPath);
		
		AsmScanning.readInSymbols(asmPath, mod);
		BufferedWriter bw = new BufferedWriter(new FileWriter(cPath));
		writeCFileHead(bw, mnode.attr.get("HeaderName"));
		
		for(LiteNode child : mnode.children) {
			if(child.name.equals("Symbol")) {
				String symName = child.attr.get("Name");
				MCTSymbol mctSym = mod.symMap.get(symName);
				if(mctSym == null) {
					MyuPackagerLogger.logMessage("Data2C.doModule", "WARNING: Symbol \"" + symName + "\" specified in XML but not found in asm file! Skipping...");
					continue;
				}
				String symType = child.attr.get("Type");
				if(symType == null) symType = "uint8_t";
				
				int elementCount = 1;
				String aval = child.attr.get("Count");
				if(aval != null) {
					if(aval.startsWith("0x")) elementCount = Integer.parseUnsignedInt(aval.substring(2), 16);
					else elementCount = Integer.parseUnsignedInt(aval);
				}
				int sizeBytes = elementCount;
				
				//Parse asm based on sym type...
				if(symType.endsWith("*")) {
					//Pointer table.
					sizeBytes <<= 2;
					FileBuffer rawdat = asmLines2Bin(mctSym, sizeBytes); //Honestly easier to just convert back to bin?
					List<String> elements = new ArrayList<String>(elementCount);
					
					for(long p = 0; p < sizeBytes; p+=4) {
						long val = Integer.toUnsignedLong(rawdat.intFromFile(p));
						//Check for matching symbol.
						SymbolInfo sinfo = symbolMapAddr.get(val);
						if(sinfo != null) {
							elements.add(sinfo.name);
						}
						else {
							elements.add(String.format("(%s)0x%08x", symType, val));
						}
					}
					
					printSymbolToCFile(bw, mctSym.address, symName, symType, elements, 4);
				}
				else if(structDefs.containsKey(symType)) {
					//Defined struct
					StructDef def = structDefs.get(symType);
					sizeBytes *= def.size;
					FileBuffer rawdat = asmLines2Bin(mctSym, sizeBytes);
					rawdat.setCurrentPosition(0L);
					List<String> elements = new ArrayList<String>(elementCount);
					byte[] buffer = new byte[def.size];
					while(rawdat.bytesRemaining() >= def.size) {
						for(int i = 0; i < def.size; i++) {
							buffer[i] = rawdat.nextByte();
						}
						String el = def.toC(buffer);
						elements.add(el);
					}
					
					printSymbolToCFile(bw, mctSym.address, symName, symType, elements, def.perLine);
				}
				else {
					//Assumed integral, but if not then throw error.
					if(symType.endsWith("int16_t")) sizeBytes <<= 1;
					if(symType.endsWith("int32_t") || symType.equals("float")) sizeBytes <<= 2;
					if(symType.endsWith("int64_t") || symType.equals("double")) sizeBytes <<= 3; //I don't even think int64 is really a thing for PSX? But double is ig
					
					FileBuffer rawdat = asmLines2Bin(mctSym, sizeBytes);
					int ePerLine = 16;
					List<String> elements = new ArrayList<String>(elementCount);
					if(symType.equals("uint8_t")) {
						for(long p = 0; p < sizeBytes; p++) {
							int b = Byte.toUnsignedInt(rawdat.getByte(p));
							elements.add(String.format("0x%02x", b));
						}
					}
					else if(symType.equals("int8_t")) {
						for(long p = 0; p < sizeBytes; p++) {
							elements.add(String.format("%d", rawdat.getByte(p)));
						}
					}
					else if(symType.equals("uint16_t")) {
						ePerLine = 8;
						for(long p = 0; p < sizeBytes; p+=2) {
							int b = Short.toUnsignedInt(rawdat.shortFromFile(p));
							elements.add(String.format("0x%04x", b));
						}
					}
					else if(symType.equals("int16_t")) {
						ePerLine = 8;
						for(long p = 0; p < sizeBytes; p+=2) {
							elements.add(String.format("%d", rawdat.shortFromFile(p)));
						}
					}
					else if(symType.equals("uint32_t")) {
						ePerLine = 8;
						for(long p = 0; p < sizeBytes; p+=4) {
							int b = rawdat.intFromFile(p);
							elements.add(String.format("0x%08x", b));
						}
					}
					else if(symType.equals("int32_t")) {
						ePerLine = 8;
						for(long p = 0; p < sizeBytes; p+=4) {
							elements.add(String.format("%d", rawdat.intFromFile(p)));
						}
					}
					else if(symType.equals("float") || symType.equals("single")) {
						ePerLine = 8;
						for(long p = 0; p < sizeBytes; p+=4) {
							float f = Float.intBitsToFloat(rawdat.intFromFile(p));
							elements.add(String.format("%.5ff", f));
						}
					}
					else if(symType.equals("double")) {
						ePerLine = 4;
						for(long p = 0; p < sizeBytes; p+=8) {
							double f = Double.longBitsToDouble(rawdat.longFromFile(p));
							elements.add(String.format("%.8f", f));
						}
					}
					else {
						MyuPackagerLogger.logMessage("Data2C.doModule", "WARNING: Symbol type \"" + symType + "\" not recognized! Skipping...");
						continue;
					}
					printSymbolToCFile(bw, mctSym.address, symName, symType, elements, ePerLine);
				}
				
			}
		}
		
		writeCFileFoot(bw);
		bw.close();
	}
	
	private void importXMLNode(LiteNode node) {
		//So can do easy recursion
		if(node.name != null) {
			if(node.name.equals("Module")) {
				modInfoList.add(node);
				return;
			}
			else if(node.name.equals("SymbolList")) {
				String path = node.attr.get("Path");
				if(path != null) symListPaths.add(path);
				return;
			}
			else if(node.name.equals("StructDef")) {
				StructDef def = StructDef.fromXMLNode(node);
				structDefs.put(def.name, def);
				return;
			}
		}
		
		for(LiteNode child : node.children) importXMLNode(child);
	}
	
	private void importXML() {
		xmldir = xmlpath;
		xmldir = MyuArcCommon.getContainingDir(xmlpath);

		//Allocate lists
		symListPaths = new LinkedList<String>();
		symbolMapAddr = new HashMap<Long, SymbolInfo>();
		symbolMapName = new HashMap<String, SymbolInfo>();
		modInfoList = new LinkedList<LiteNode>();
		structDefs = new HashMap<String, StructDef>();
		
		LiteNode xmlRoot = MyuArcCommon.readXML(xmlpath);
		importXMLNode(xmlRoot);
	}
	
	public static void main_data2c(Map<String, String> argmap) throws IOException {
		Data2C ctx = new Data2C();
		if(!ctx.checkArgs(argmap)) {
			MyuPackagerLogger.logMessage("Data2C.main_data2c", 
					"Arg check failed!");
			Main.printUsage_Data2C();
			System.exit(1);
		}
		
		if(ctx.xmlpath == null) {
			MCTModule mod = new MCTModule();
			mod.modName = ctx.modName;
			
			MyuPackagerLogger.logMessage("Data2C.main_data2c", 
					"Reading " + ctx.inpath + "...");
			AsmScanning.readInSymbols(ctx.inpath, mod);
			
			if(mod.dataSymbols.isEmpty()) {
				MyuPackagerLogger.logMessage("Data2C.main_data2c", 
						"Module \"" + mod.modName + "\" ");
			}
			
			BufferedWriter bw = new BufferedWriter(new FileWriter(ctx.outpath));
			writeCFileHead(bw, ctx.headerName);
			
			for(MCTSymbol sym : mod.dataSymbols) {
				printSymbolToCFile(sym, bw);
			}
			
			writeCFileFoot(bw);
			bw.close();
		}
		else {
			ctx.importXML();
			
			//Load symbols
			for(String spath : ctx.symListPaths) {
				spath = MyuArcCommon.unixRelPath2Local(ctx.xmldir, spath);
				MyuPackagerLogger.logMessage("Data2C.main_data2c", 
						"Loading symbol table from " + spath);
				List<SymbolInfo> slist = SymbolList.readSplatSymbolList(spath);
				if(slist != null) {
					for(SymbolInfo sym : slist) {
						ctx.symbolMapAddr.put(sym.address, sym);
						ctx.symbolMapName.put(sym.name, sym);
					}
				}
			}
			
			//Do modules
			for(LiteNode mnode : ctx.modInfoList) {
				ctx.doModule(mnode);
			}
		}

	}

}
